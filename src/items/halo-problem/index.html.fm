---
title: The Halo Problem
tags: [math, programming]
date: 2019-11-23
desc: "A strange problem I had when coding"
layout: post
requires: [mathjax, notes, syntax-highlighting]

indexed: false
---

<p>I'd like to tell you about an interesting problem I ran accross when doing a problem for my graphics class...</p>

<p><note-ref to="skipping">Skipping much of the class,</note-ref> we'll start when I implemented intersection of two objects in 3d space:</p>

<note-def id="skipping">
  <p>In my class, we've been coding simple object rendering. We started with 2D, rendering simple colored polygons:</p>

  <div class="figure">
    <img src="pics/cropped/00-2d-unclipped.png" />
    <p class="caption">A colored polygon</p>
  </div>

  <p>and then we allowed the user to clip said polygons:</p>

  <div class="figure">
    <img src="pics/cropped/01-2d-clipped.png" />
    <p class="caption">A clipped polygon</p>
  </div>

  <p>And then we moved onto 3D! This started out with rendering simple wireframes, for instance this torus:</p>

  <div class="figure">
    <img src="pics/cropped/02-3d-wireframe.png" />
    <p class="caption">A torus displayed as a 3d wireframe</p>
  </div>

  <p>and we implemented an optimization called "backface elimiation" which improves rendering some shapes:</p>

  <div class="figure">
    <img src="pics/cropped/03-3d-backface.png" />
    <p class="caption">Backface elimination removes the 'back' of the torus</p>
  </div>

  <p>... but isn't perfect ...</p>

  <div class="figure">
    <img src="pics/cropped/04-3d-backface-turned.png" />
    <p class="caption">Backface elimination does not work perfectly on a torus</p>
  </div>

  <p>Then we painted the objects so they were more than just wireframes:</p>

  <div class="figure">
    <img src="pics/cropped/05-3d-painted.png" />
    <p class="caption">A painted torus</p>
  </div>

  <p><note-ref to="multiple-timing">And accounted for multtiple objects at once:</note-ref></p>

  <note-def id="multiple-timing">
    <p>Actually, I'm not sure where exactly this came in the timeline. It's not important.</p>
  </note-def>

  <div class="figure">
    <img src="pics/cropped/06-3d-painted-multiple.png" />
    <p class="caption">A painted torus next to a painted sphere</p>
  </div>

  <p>Then we added lighting!</p>

  <div class="figure">
    <img src="pics/cropped/07-3d-lit.png" />
    <img src="pics/cropped/08-3d-lit-multiple.png" />
    <p class="caption">A torus next to a sphere, both lit</p>
  </div>

  <p><note-ref to="intersecting-timing">Finally, accounted for objects intersecting, which I will discuss after this footnote...</note-ref></p>

  <note-def id="intersecting-timing">
    <p>This is actually a slight lie: I accounted for intersections <em>before</em> doing lighting. But this order works better for the blog post.</p>
  </note-def>
</note-def>

<div class="figure">
  <img src="pics/cropped/09-3d-correct_intersection.png" />
  <p class="caption">A torus and sphere intersecting</p>
</div>

<p>The problem of how to allow for intersections like this is actually a bit subtle.</p>

<p>See, the naive rendering implementation is just to render objects back-to-front. Take a list of objects, sort it by distance to observer, and draw the objects, farthest-to-closest. In order to do the sort, we would call <code>qsort</code> with a <code>comparator</code> function which compares two object and tells <code>qsort</code> which one should come before the other in the list.</p>

<p>This <code>comparator</code> would look <note-ref to="something-like-this">something like this</note-ref>:</p>

<note-def id="something-like-this">
  <p>... except written in C, not pseudo-JS.</p>
</note-def>

<pre><code class="javascript">function comparator(object1, object2) {
  // Order by distance
  let distance1 = distance_to_observer(object1);
  let distance2 = distance_to_observer(object2);
  if (distance1 > distance2) return PAINT_OBJECT1_FIRST;
  if (distance2 > distance1) return PAINT_OBJECT2_FIRST;
  return PAINT_EITHER_FIRST;
}
</code></pre>

<p>However, this cannot render any intersections, since each objects is rendered wholesale, one-at-a-time.</p>

<p>Instead, you need to decompose all objects into their constituent polygons, put them all in a list, sort <em>that</em> by distance to observer, and paint each <em>polygon</em> one-at-a-time. So that's what we did. The comparator looked like the following:</p>

<pre><code class="javascript">function comparator(poly1, poly2) {
  // Order by distance
  let distance1 = distance_to_observer(poly1);
  let distance2 = distance_to_observer(poly2);
  if (distance1 > distance2) return PAINT_POLY1_FIRST;
  if (distance2 > distance1) return PAINT_POLY2_FIRST;
  return PAINT_EITHER_FIRST;
}
</code></pre>

<p>And it worked great! (As is evident by the existence of the photo in which clipping is working correctly)</p>

<p>Now is where things start getting funky. See, the user was able to manipulate one object at a time with the keyboard. I visually cued which object was selected by changing the color of its wireframe:</p>

<div class="figure">
  <img src="pics/cropped/10-3d-wireframe-selection-1.png" />
  <img src="pics/cropped/11-3d-wireframe-selection-2.png" />
  <p class="caption">Selection was cued by a change of wireframe color</p>
</div>

<p>but I wasn't happy with this (for a few reasons). Instead, I wanted to do something cooler: I wanted to draw a halo around whichever object was selected:</p>

<div class="figure">
  <img src="pics/cropped/12-3d-correct_halo-1.png" />
  <img src="pics/cropped/13-3d-correct_halo-2.png" />
  <p class="caption">Cueing selection with a halo instead</p>
</div>

<p>Looking at the above images, you may think I succeeded in doing so. And I did! Kind of. With those particular objects in those particular positions with those particular rotations, the halos render correctly. In general, however, they don't. As it turns out, the problem of how to render these halos is quite tricky...</p>

<p>I decided, first of all, that the halo should be made by <note-ref to="select-option">running through each polygon of the selected object, dilating it around its center</note-ref>, and making it red. All these red polygons get thrown into the same list as the rest of the polygons, and get sorted, with the rest of the polygons, into some display order.</p>

<note-def id="select-option">
  <p>Another option is to dilate the object as a whole around its center; however, this has some issues. It would work perfectly on a sphere but wouldn't work as well on a torus: the inside of the torus would get no halo.</p>
</note-def>

<p>The question is then simply: where in the display order do these red polygons belong?</p>

<p>Now, we would want the comparator to look something like this:</p>

<pre><code class="javascript">function comparator(poly1, poly2) {
  // Place focused polygons behind unfocused polygons
  if (is_focused(poly1) && !is_focused(poly2)) return PAINT_POLY1_FIRST;
  if (is_focused(poly2) && !is_focused(poly1)) return PAINT_POLY2_FIRST;

  // Otherwise, order by distance
  let distance1 = distance_to_observer(poly1);
  let distance2 = distance_to_observer(poly2);
  if (distance1 > distance2) return PAINT_POLY1_FIRST;
  if (distance2 > distance1) return PAINT_POLY2_FIRST;

  return PAINT_EITHER_FIRST;
}
</code></pre>

<p>...unfortunately, this doesn't work so well:</p>

<div class="figure">
  <img src="pics/cropped/14-3d-naive_comparator.png" />
  <p class="caption">The naive comparator algorithm does not work well</p>
</div>

<p>The issue is that each red poylgon is being placed <em>just behind</em> its purple counterpart. Since each red polygon is enlarged, it thus obscures all the purple polygons behind it.</p>

<p>Okay, I said, let's try again. In order to avoid the previous problem, we'll place each red polygon behind <em>all</em> polygons from the focused model. Otherwise, we'll sort by distance:</p>

<pre><code class="javascript">function comparator(poly1, poly2) {
  // Place focused polygons behind unfocused polygons,
  // but ONLY compare polygons from the focused model
  if (   (is_red(poly1) || is_in_focused_polygon(poly1))
      && (is_red(poly2) || is_in_focused_polygon(poly2)) ) {
    if (is_focused(poly1) && !is_focused(poly2)) return PAINT_POLY1_FIRST;
    if (is_focused(poly2) && !is_focused(poly1)) return PAINT_POLY2_FIRST;
  }

  // Otherwise, order by distance
  let distance1 = distance_to_observer(poly1);
  let distance2 = distance_to_observer(poly2);
  if (distance1 > distance2) return PAINT_POLY1_FIRST;
  if (distance2 > distance1) return PAINT_POLY2_FIRST;

  return PAINT_EITHER_FIRST;
}
</code></pre>

<p>Unfortunately, this also doesn't work. However, it fails much more subtly... It appears to work at first&mdash;in fact, this is the comparator function I used to generate the original "correct" halo images. However, weird stuff starts to happen.</p>

<p>For instance, sometimes polygons would render out-of-order or not rendered at all:</p>

<div class="figure">
  <img src="pics/cropped/15-3d-weird_rendering-1.png" />
  <img src="pics/cropped/16-3d-weird_rendering-2.png" />
  <img src="pics/cropped/17-3d-weird_rendering-3.png" />
  <img src="pics/cropped/18-3d-weird_rendering-4.png" />
  <p class="caption">Due to halos, some polygons are rendered out of order or not at all</p>
</div>

<p>Even weirder, I found a setup with a torus and a sphere in which the torus would render differently based on how the sphere was rotated:</p>

<div class="figure">
  <img src="pics/cropped/22-3d-incorrect_intersection-weird-1.png" />
  <img src="pics/cropped/23-3d-incorrect_intersection-weird-2.png" />
  <img src="pics/cropped/24-3d-incorrect_intersection-weird-3.png" />
  <p class="caption">As the sphere is rotated, polygons on the top of the torus begin to render incorrectly</p>
</div>

<p>So what the hell is going on?</p>

<p>When I first encountered this, I pondered for a bit, confuddled. But I think I figured it out.</p>

<p>Consider more weird behavior in which the apparent overlapping of two objects will depend on which object is selected:</p>

<div class="figure">
  <img src="pics/cropped/19-3d-incorrect_intersection-overlapping-1.png" />
  <img src="pics/cropped/20-3d-incorrect_intersection-overlapping-2.png" />
  <img src="pics/cropped/21-3d-incorrect_intersection-overlapping-3.png" />
  <p class="caption">The object that appears 'on top' depends on which object is selected (either way, the halo appears 'behind')</p>
</div>

<p>In actuality, the sphere is clipping into the torus (as can be seen by the left image, where nothing is selected), and the left image is closer to the truth than the right image. However, I claim that, using <code>comparator</code>, I can prove&mdash;as long as the torus is selected&mdash;that the leftmost polygon on the torus is closer to the observer than the closest polygon on the sphere, and thus should be painted on top.</p>

<p>The proof is as follows:</p>
<ol>
  <li>Assume the torus is selected.</li>
  <li>Call the rightmost red polygon $R$, the leftmost torus polygon $T$, and the closest sphere polygon $S$.</li>
  <li>Note that since $R$ is red and $T$ is purple, then <code>comparator(R, T) == PAINT_POLY1_FIRST</code>, meaning that $R$ is behind $T$.</li>
  <li>Now note that since $R$ is closer to the observer than $S$, then $S$ is behind $R$.</li>
  <li>Since $S$ is behind $R$ and $R$ is behind $T$, we conclude (wrongly) that $S$ is behind $T$.</li>
</ol>

<p>I conjecture that these kinds of proofs are what <code>qsort</code> is doing, causing this strange behavior.</p>

<p>Actually, it turns out that we can also prove that $T$ is behind $S$ simply by comparing their distances to the observer. Thus, $S$ is behind $T$ and $T$ is behind $S$. But that's very clearly a contradiction!</p>

<p>The issue lies in transitivity. We're assuming that $a < b \land b < c \implies a < c$; we're assuming that <code>coparator</code> is a total ordering when, in fact, it's not.</p>

<p>So I thought that that was an interesting bug. I hope you enjoyed! I still don't know what algorithm I <em>should</em> use for <code>comparator</code>...</p>
